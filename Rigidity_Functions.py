import itertools
import networkx as nx
import matplotlib.pyplot as plt
import pyperclip

#The distance function creates M2 code for the length of an edge.
def distance(field,edge):
    M2_code="(x_"+str(edge[0])+"-x_"+str(edge[1])+")^2+(y_"+str(edge[0])+"-y_"+str(edge[1])+")^2-random("+field+")"
    return(M2_code)

#Creates the M2 code for the ideal generated by the euclidean distance between each vertice
def degree_code(G,field,root):
    vertices=G[0]
    edges=G[1]
    root=str(root)
    field=str(field)
    string="R="+field+"["
    #creates the ring which we will be working over
    for i in range(vertices):
        if i==vertices-1:
            string=string+"x_"+str(i)+",y_"+str(i)+"]; I=ideal(x_0,y_0,x_1+"+root+"*y_1-1,"
        else:
            string=string+"x_"+str(i)+",y_"+str(i)+","
    #creates the ideal
    for i in range(len(edges)):
        if i==len(edges)-1:
            string=string+distance(field,edges[i])+"); degree(I)"
        else:
            string=string+distance(field,edges[i])+","
    print(string)
    return(string)


#outputs all the subsets of a given list
def subsets(s):  
    if len(s) == 0:  
        return [[]]  
    x = subsets(s[:-1])  
    return x + [[s[-1]] + y for y in x]  

def flatten_list(nested_list):
    return list(itertools.chain(*nested_list))

#Function to check whether the inputted graph is rigid and/or Laman
def Laman_check(G):
    vertices=list(range(G[0]))
    edges=G[1]
    if len(edges)<2*len(vertices)-3:
        print("Not Rigid")
        return("False")
    if len(edges)==2*len(vertices)-3:
        vertice_subsets=subsets(vertices)
        for subset in vertice_subsets:
            remaining_edges= [lst for lst in edges if any(x in lst for x in vertices)]
            if 2*len(subset)-3>len(remaining_edges):
                print("Not Laman")
                return(False)
            print("Laman")
            return(True)
    subset_vertices=subsets(vertices)
    for subset in subset_vertices:
        remaining_edges= [lst for lst in edges if any(x in lst for x in vertices)]
        if len(subset)!=2*len(subset)-3:
            continue
        vertice_subsets=subsets(subset)
        for vertex_subset in vertice_subsets:
            remaining_vertex_edges= [lst for lst in edges if any(x in lst for x in vertex_subset)]
            if 2*len(vertex_subset)-3>len(remaining_vertex_edges):
                print("Not Laman")
                return(False)
            print("Rigid but not Laman")
            return(True)

    
  
# Code for creating the graph visuals 
class GraphVisualization: 
   
    def __init__(self): 
          
        # visual is a list which stores all  
        # the set of edges that constitutes a 
        # graph 
        self.visual = [] 
          
    # addEdge function inputs the vertices of an 
    # edge and appends it to the visual list 
    def addEdge(self, a, b): 
        temp = [a, b] 
        self.visual.append(temp) 
          
    # In visualize function G is an object of 
    # class Graph given by networkx G.add_edges_from(visual) 
    # creates a graph with a given list 
    # nx.draw_networkx(G) - plots the graph 
    # plt.show() - displays the graph 
    def visualize(self): 
        G = nx.Graph() 
        G.add_edges_from(self.visual) 
        nx.draw_networkx(G) 
        plt.show() 
  
# Driver code 
G = GraphVisualization() 
def graph_plot(G):
    graph=GraphVisualization() 
    for edge in G[1]:
        graph.addEdge(edge[0],edge[1])
    graph.visualize()
    
#runs all of the functions above for a given graph, automatically copying the outputted M2 code to your clipboard
def Run_all(G, field, root):
    pyperclip.copy(degree_code(G,field,root))
    Laman_check(G)
    graph_plot(G)

#Below are the functions for creating the Genus M2 code

def distance_genus(field,edge):
    M2_code="(x_"+str(edge[0])+"-x_"+str(edge[1])+")^2+(y_"+str(edge[0])+"-y_"+str(edge[1])+")^2-random("+field+")*Z^2"
    return(M2_code)

#the root input is the root of negative 1 over the given field 
def genus_code(G,field,root,removed_edge, zero, one):
    vertices=G[0]
    edges=G[1].copy()
    zero_vert=str(removed_edge[0])
    one_vert=str(removed_edge[1])
    zero_vert=str(zero)
    one_vert=str(one)
    try:
        edges.remove(removed_edge)
    except:
        removed_edge.reverse()
        edges.remove(removed_edge)
    root=str(root)
    field=str(field)
    string="R="+field+"[Z,"
    #creates the ring which we will be working over
    for i in range(vertices):
        if i==vertices-1:
            string=string+"x_"+str(i)+",y_"+str(i)+"]; I=ideal(x_"+zero_vert+",y_"+zero_vert+",x_"+one_vert+"+"+root+"*y_"+one_vert+"-Z,"
        else:
            string=string+"x_"+str(i)+",y_"+str(i)+","
    #creates the ideal
    for i in range(len(edges)):
        if i==len(edges)-1:
            string=string+distance_genus(field,edges[i])+"); satI=saturate(I,Z); V=Proj(R/satI); genus(V)"
        else:
            string=string+distance_genus(field,edges[i])+","
    return(string)

def Genus_Run(G, field, root, removed_edge, zero, one):
    pyperclip.copy(genus_code(G,field,root,removed_edge, zero, one))
    vertices=G[0]
    edges=G[1].copy()
    try:
        edges.remove(removed_edge)
    except:
        removed_edge.reverse()
        edges.remove(removed_edge)
    G=[vertices,edges]
    graph_plot(G)
