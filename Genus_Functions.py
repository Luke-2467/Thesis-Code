import itertools
import networkx as nx
import matplotlib.pyplot as plt
import pyperclip

#The distance function creates M2 code for the distance between two vertices, assigning some random distance
def distance(ring,edge):
    M2_code="(x_"+str(edge[0])+"-x_"+str(edge[1])+")^2+(y_"+str(edge[0])+"-y_"+str(edge[1])+")^2-random("+ring+")*Z^2"
    return(M2_code)

#this creates the M2 code for the ideal generated by the euclidean distance between each vertice
def graph_code(ring,G):
    vertices=G[0]
    edges=G[1]
    string="R="+ring+"[Z,"
    for i in range(vertices):
        if i==vertices-1:
            string=string+"x_"+str(i)+",y_"+str(i)+"]; I=ideal(x_0,y_0,y_1,"
        else:
            string=string+"x_"+str(i)+",y_"+str(i)+","
    for i in range(len(edges)):
        if i==len(edges)-1:
            string=string+distance(ring,edges[i])+"); satI=saturate(I,Z); V=Proj(R/satI); genus(V)"
        else:
            string=string+distance(ring,edges[i])+","
    return(string)


#create list of all subsets of a list function
def subsets(s):  
    if len(s) == 0:  
        return [[]]  
    x = subsets(s[:-1])  
    return x + [[s[-1]] + y for y in x]  

def flatten_list(nested_list):
    return list(itertools.chain(*nested_list))

#create laman check function, this checks if a given graph is Laman
def Laman_check(G):
    vertices=list(range(G[0]))
    edges=G[1]
    if len(edges)<2*len(vertices)-3:
        print("Not Rigid")
        return("False")
    if len(edges)==2*len(vertices)-3:
        vertice_subsets=subsets(vertices)
        for subset in vertice_subsets:
            remaining_edges= [lst for lst in edges if any(x in lst for x in vertices)]
            if 2*len(subset)-3>len(remaining_edges):
                print("Not Laman")
                return(False)
            print("Laman")
            return(True)
    subset_vertices=subsets(vertices)
    for subset in subset_vertices:
        remaining_edges= [lst for lst in edges if any(x in lst for x in vertices)]
        if len(subset)!=2*len(subset)-3:
            continue
        vertice_subsets=subsets(subset)
        for vertex_subset in vertice_subsets:
            remaining_vertex_edges= [lst for lst in edges if any(x in lst for x in vertex_subset)]
            if 2*len(vertex_subset)-3>len(remaining_vertex_edges):
                print("Not Laman")
                return(False)
            print("Rigid but not Laman")
            return(True)

    #graph visualisation code
    
# First networkx library is imported  
# along with matplotlib 
import networkx as nx 
import matplotlib.pyplot as plt 
   
  
# Defining a Class 
class GraphVisualization: 
   
    def __init__(self): 
          
        # visual is a list which stores all  
        # the set of edges that constitutes a 
        # graph 
        self.visual = [] 
          
    # addEdge function inputs the vertices of an 
    # edge and appends it to the visual list 
    def addEdge(self, a, b): 
        temp = [a, b] 
        self.visual.append(temp) 
          
    # In visualize function G is an object of 
    # class Graph given by networkx G.add_edges_from(visual) 
    # creates a graph with a given list 
    # nx.draw_networkx(G) - plots the graph 
    # plt.show() - displays the graph 
    def visualize(self): 
        G = nx.Graph() 
        G.add_edges_from(self.visual) 
        nx.draw_networkx(G) 
        plt.show() 
  
# Driver code 
G = GraphVisualization() 

def graph_plot(G):
    graph=GraphVisualization() 
    for edge in G[1]:
        graph.addEdge(edge[0],edge[1])
    graph.visualize()
    
    
def Run_all(G, ring):
    pyperclip.copy(graph_code(ring,G))
    Laman_check(G)
    graph_plot(G)


